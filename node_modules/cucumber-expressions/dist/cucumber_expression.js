'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _match_arguments = require('./match_arguments');

var _match_arguments2 = _interopRequireDefault(_match_arguments);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var CucumberExpression = function () {
  /**
   * @param expression
   * @param types Array of type name (String) or types (function). Functions can be a regular function or a constructor
   * @param transformLookup
   */
  function CucumberExpression(expression, types, transformLookup) {
    _classCallCheck(this, CucumberExpression);

    var parameterPattern = /\{([^}:]+)(:([^}]+))?}/g;
    var optionalPattern = /\(([^\)]+)\)/g;

    this._expression = expression;
    this._transforms = [];
    var regexp = "^";
    var typeIndex = 0;
    var match = void 0;
    var matchOffset = 0;

    // Create non-capturing, optional capture groups from parenthesis
    expression = expression.replace(optionalPattern, '(?:$1)?');

    while ((match = parameterPattern.exec(expression)) !== null) {
      var parameterName = match[1];
      var typeName = match[3];
      var type = types.length <= typeIndex ? null : types[typeIndex++];

      var transform = void 0;
      if (type) {
        transform = transformLookup.lookupByType(type);
      }
      if (!transform && typeName) {
        transform = transformLookup.lookupByTypeName(typeName, false);
      }
      if (!transform) {
        transform = transformLookup.lookupByTypeName(parameterName, true);
      }
      if (!transform) {
        transform = transformLookup.createAnonymousLookup(function (s) {
          return s;
        });
      }
      this._transforms.push(transform);

      var text = expression.slice(matchOffset, match.index);
      var captureRegexp = getCaptureRegexp(transform.captureGroupRegexps);
      matchOffset = parameterPattern.lastIndex;
      regexp += text;
      regexp += captureRegexp;
    }
    regexp += expression.slice(matchOffset);
    regexp += "$";
    this._regexp = new RegExp(regexp);
  }

  _createClass(CucumberExpression, [{
    key: 'match',
    value: function match(text) {
      return (0, _match_arguments2.default)(this._regexp, text, this._transforms);
    }
  }, {
    key: 'source',
    get: function get() {
      return this._expression;
    }
  }]);

  return CucumberExpression;
}();

function getCaptureRegexp(captureGroupRegexps) {
  if (captureGroupRegexps.length === 1) {
    return '(' + captureGroupRegexps[0] + ')';
  }

  var captureGroups = captureGroupRegexps.map(function (group) {
    return '(?:' + group + ')';
  });

  return '(' + captureGroups.join('|') + ')';
}

exports.default = CucumberExpression;